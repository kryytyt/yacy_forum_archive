<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="generator" content="Hugo 0.37.1" />

  <title> &middot; Yacy Old Forum Archiv</title>

  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/pure-min.css">

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-old-ie-min.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-min.css">
  <!--<![endif]-->

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="/css/side-menu-old-ie.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="/css/side-menu.css">
  <!--<![endif]-->

  <link rel="stylesheet" href="/css/blackburn.css">

  
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  
  <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

 
  

  

  <link rel="shortcut icon" href="img/favicon.ico" type="image/x-icon" />

  
  

</head>


<body>
<div id="layout">

  
<a href="#menu" id="menuLink" class="menu-link">
  
  <span></span>
</a>
<div id="menu">

  

  <div class="pure-menu">
    <ul class="pure-menu-list">
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="/"><i class='fa fa-home fa-fw'></i>Home</a>
      
        </li>
      
    </ul>
  </div>

  <div class="pure-menu social">
  <ul class="pure-menu-list">

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://twitter.com/http://twitter.com/yacy_search" target="_blank"><i class="fa fa-twitter-square fa-fw"></i>Twitter</a>
    </li>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://github.com/yacy" target="_blank"><i class="fa fa-github-square fa-fw"></i>GitHub</a>
    </li>
    

    

    

    

    

    

    

    

    

    

    

    

    

  </ul>
</div>


  <div>
  <div class="small-print">
    <small></small>
  </div>
  <div class="small-print">
    <small>Built with&nbsp;<a href="https://gohugo.io/" target="_blank">Hugo</a></small>
    <small>Theme&nbsp;<a href="https://github.com/yoshiharuyamashita/blackburn" target="_blank">Blackburn</a></small>
  </div>
</div>

</div>


  <div id="main">


<div class="header">
  <h1></h1>
  <h2></h2>
</div>
<div class="content">
  

<h1 id="ich-habe-hier-vorhin-mal-openssl-auf-1-1-updaten-wollen">Ich habe hier vorhin mal OpenSSL auf 1.1 updaten wollen, ...</h1>

<p>Date: 2016-08-28 00:12:33</p>

<p>Ich habe hier vorhin mal OpenSSL auf 1.1 updaten wollen, und das
zerschießt einmal die gesamte Infrastruktur. Also so einmal alles. Die
haben diverse interne Typen opak gemacht, und die ganze Software da
draußen greift halt hemmungslos auf diese internen Datenstrukturen zu.
Und man ist ja auch immer wieder überrascht, wie viel Software so gegen
OpenSSL linkt.</p>

<p>Die Shared Library hat eine neue Version, d.h. man muss einmal alle
Software neu bauen. wget, curl, alles. curl baut gegen das neue OpenSSL,
aber ist damit allein auf weiter Flur. wget musste ich patchen, mutt
musste ich patchen, neon (für Subversion) musste ich patchen. git war
gut. Der SSL-Code aus gatling geht überraschenderweise auch ohne
Änderung. Aber sonst so? Kahlschlag.</p>

<p>Python baut zum Beispiel nur die Module _hashlib und _ssl nicht mit.
Ihr könnt euch ja ausmalen, was das alleine an
Folge-Infrastrukturapokalypse nach sich zieht. Bei mir konkret geht
daher gerade SCons nicht, welches das Buildsystem von serf ist, ohne das
ich Subversion nicht reparieren kann.</p>

<p>Die Perl-Module gingen auch. Aber so gefühlt ist über die Hälfte der
Software jetzt zerbrochen.</p>

<p>Ich hätte mir ehrlich gesagt erhofft, dass die OpenSSL-Leute da eine
klitzekleine Warnung in ihren Bart säuseln, bevor sie so eine Apokalypse
lostreten.</p>

<p>Auf der anderen Seite ist das ja auch ein schöner Impuls, mal generell
von diesem OpenSSL wegzumigrieren.</p>

<p><strong>Update</strong>: <a href="https://breakpoint.cc/openssl-1.1-rebuild-2016-08-26/">Bei Debian hat es auch das eine oder andere Paket
zerrissen</a>.</p>

<p><strong>Update</strong>: Ein Leserbrief dazu:</p>

<blockquote>
<p>Wollte nur kurz darauf hinweisen, daß die API-Änderungen bei OpenSSL
1.1 nicht nur jede Menge inkompatibilitäten nach sich ziehen, bei
denen was laut kaputt geht (compiletime error), sondern auch
API-Änderungen dabei sind, die stillschweigend security-buigs erzeugen
können.</p>

<p>Beispiel: Die HMAC manpage sagt:</p>

<pre><code>   HMAC_Init_ex() initializes or reuses a HMAC_CTX structure to use the
   function evp_md and key key. Either can be NULL, in which case the
   existing one will be reused.
</code></pre>

<p>HMAC_Init_ex liefert erst seit kurzem einen Fehlerstatus zurück -
früher hatte sie keinen Rückgabewert und konnte nicht fehlschlagen.
Daher testet auch ne Menge Software nicht auf sowas, und das wra bis
vor kurzem auch korrekt.</p>

<p>In OpenSSL 1.1 gibt es aber folgende Änderung:</p>

<pre><code>    /* If we are changing MD then we must have a key */
    if (md != NULL &amp;&amp; md != ctx-&gt;md &amp;&amp; (key == NULL || len &lt; 0))
        return 0;
</code></pre>

<p>d.h. anders als dokumentiert, kann nicht \&ldquo;either NULL\&rdquo; sein. Aber
alte Software kann das nicht prüfen, und welche HMAC dann im Endeffekt
berechnet wird, steht in den Sternen.</p>

<p>Die Reaktion von OpenSSL upstream war, die Doku zu ändern.</p>

<p>D.h. nicht nur breaked openssl die API (teilweise unnötig) so, daß
Programme nicht mehr kompilieren, nein Programme, die mal korrekt
waren und jetzt immer noch kompilieren haben jetzt unter Umständen
größere Sicherheitslöcher.</p>

<p>(Es gibt eine Reihe ähnlicher stiller API-Änderungen in OpenSSL 1.1)</p>

<p>(und ja, wegmigrieren hört sich gut an, aber es gibt häufig keine
alternative mit gleichen Funktionsumfang ohne diese Probleme - gnutls
hat z.b. mindestens bis vor kurzem kein RSA-OEAP padding unterstützt,
sondern nur das extrem anfällige kaputte PKCS-padding).</p>
</blockquote>

<p>Und zu meiner Aussage, dass interne Typen opak gemacht wurden,
kommentiert der Einsender noch:</p>

<blockquote>
<p>Das, so würde ich sagen, ist falsch. Erstens sind viele dieser
Datentypen nicht intern, sondern man musste früher darauf zugreifen
weil es keine accessors gab und das auch so dokumentiert war, und
zweitens ist das Hautproblem nicht, daß die Typen opak sind, sondern
daß man früher structs selbst allozieren musste und das jetzt nicht
mehr geht, d.h. alter code nicht compiliert, auch wenn er nicht auf
irgendwelche strukturen zugegriffen hat.</p>

<p>Der Hintergrund für viele solche Änderungen war, daß man man structs
nicht mehr auf dem Stack hat - sehr löblich. Das wurde aber so gelöst,
daß man jetzt alles dynamisch über eine spezielle openssl-Funktion
allozieren muss, die es früher nicht gab, und code, der die structs
selbst deklariert hast, schlägt fehl, weil der Typ opak ist, auch,
wenn garnicht darauf zugegriffen wird.</p>

<p>Im Allgemeinen ist es deshalb nicht möglich, code zu schreiben, der
mit der neuen und der alten API funktioniert (also, ohne
#if-massengrab).</p>
</blockquote>

<p>Mir ist aufgefallen, dass auch Code mit #if-Massengrab bricht mit
Version 1.1. Früher konnte man mit OPENSSL_NO_SSL2 gucken, ob die
verwendete Version mit SSL2-Support kommt oder nicht. OpenSSL 1.1 hat
kein SSL2 mehr, aber deklariert auch dieses Präprozessorsymbol nicht.</p>

<p><strong>Update</strong>: Noch ein Leserbrief zur OpenSSL-Version:</p>

<blockquote>
<p>OpenSSL 1.1 Unterstützung für Python ist fertig, hängt aber noch im
Codereview, weil Python Core Devs mit OpenSSL-Kenntnissen Mangelware
sind. Neben mir gibt es zur Zeit nur drei weitere aktive, von denen
zwei mit anderen Dingen beschäftigt sind. Zum Glück habe ich schon vor
einem halben Jahr mit meinem Patch angefangen angefangen und einige
Patches bei OpenSSL eingereicht. Andernfalls würden mir jetzt die
Zugriffsfunktionen auf diverse struct member fehlen.<br />
<a href="https://bugs.python.org/issue26470">https://bugs.python.org/issue26470</a></p>

<p>Zwei weitere Punkte:</p>

<p>1) Es reicht nicht, nur auf OPENSSL_VERSION_NUMBER zu prüfen. LibreSSL
hat OPENSSL_VERSION_NUMBER gekapert und missbraucht das Makro für die
eigene Versionsnummber 2.x. Man muss also immer noch zusätzlich auf
nicht-LibreSSL testen:</p>

<pre><code>#if (OPENSSL_VERSION_NUMBER &gt; 0x10100000L) || !defined(LIBRESSL_VERSION_NUMBER)
</code></pre>

<p>2) Nach sweet32 hat OpenSSL 1.0.2 nur noch einen sicheren Algorithmus
für symmetrische Verschlüsselung. ChaCha20 gibt es erst in 1.1. Ich habe
mit Richard Salz vom OpenSSL Team gesprochen. Er teilt meine Sorge,
trotzdem wird OpenSSL 1.0.2 LTS keine Unterstützung für ChaCha20
erhalten.</p>

<p><a href="https://twitter.com/ChristianHeimes/status/768434388052938756">https://twitter.com/ChristianHeimes/status/768434388052938756</a></p>
</blockquote>

<p>Nur falls jemand dachte, hey, dann bleib ich halt bei OpenSSL 1.0.2!
Übrigens sei an der Stelle der Hinweis erlaubt, dass Version vor 1.0.1
schon länger gar keine Updates mehr kriegen. Man sieht vereinzelt da
draußen noch OpenSSL 0.9er-Versionen rumfliegen. Ganz, GANZ gruselig.</p>

<p>Das mit Chacha20 war bei mir übrigens auch der Auslöser für den Umstieg
auf 1.1. OpenSSL 1.1 hat nämlich endlich Support für die
Dan-Bernstein-Erfindungen Chacha20 und Poly1305. Je älter ich werde,
desto weniger traue ich Krypto-Sachen, die nicht von djb kommen oder von
ihm abgenickt wurden. Der Mann hat einfach zu oft Recht behalten, als
alle anderen abgewunken, relativiert oder gelacht haben. Ich sehe
übrigens keinen inhaltlichen Grund, wieso man Chacha20 und Poly1305
nicht auch in 1.0.2 haben sollte, das gibt es seit Jahren für
1.0x-Versionen von OpenSSL als Patch, und LibreSSL hat es auch von
Anfang an drin. Finde ich absolut unverständlich, was das OpenSSL-Team
sich da leistet.</p>

</div>

</div>
</div>
<script src="js/ui.js"></script>






</body>
</html>

