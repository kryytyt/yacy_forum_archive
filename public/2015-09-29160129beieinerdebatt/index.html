<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="generator" content="Hugo 0.37.1" />
  <title> &middot; Yacy Old Forum Archiv</title>
  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/pure-min.css">
  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-old-ie-min.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-min.css">
  <!--<![endif]-->
  <!--[if lte IE 8]>
  <link rel="stylesheet" href="/css/side-menu-old-ie.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="/css/side-menu.css">
  <!--<![endif]-->
  <link rel="stylesheet" href="/css/blackburn.css">
  
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  
  <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
 
  
  
  <link rel="shortcut icon" href="img/favicon.ico" type="image/x-icon" />
  
  
</head>
<body>
<div id="layout">
  
<a href="#menu" id="menuLink" class="menu-link">
  
  <span></span>
</a>
<div id="menu">
  
  <div class="pure-menu">
    <ul class="pure-menu-list">
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="/"><i class='fa fa-home fa-fw'></i>Home</a>
      
        </li>
      
    </ul>
  </div>
  <div class="pure-menu social">
  <ul class="pure-menu-list">
    
    
    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://twitter.com/http://twitter.com/yacy_search" target="_blank"><i class="fa fa-twitter-square fa-fw"></i>Twitter</a>
    </li>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://github.com/yacy" target="_blank"><i class="fa fa-github-square fa-fw"></i>GitHub</a>
    </li>
    
    
    
    
    
    
    
    
    
    
    
    
    
  </ul>
</div>
  <div>
  <div class="small-print">
    <small></small>
  </div>
  <div class="small-print">
    <small>Built with&nbsp;<a href="https://gohugo.io/" target="_blank">Hugo</a></small>
    <small>Theme&nbsp;<a href="https://github.com/yoshiharuyamashita/blackburn" target="_blank">Blackburn</a></small>
  </div>
</div>
</div>
  <div id="main">
<div class="header">
  <h1></h1>
  <h2></h2>
</div>
<div class="content">
  
<h1 id="bei-einer-debatte-unter-freunden-über-protocol-buffers">Bei einer Debatte unter Freunden über Protocol Buffers, ...</h1>
<p>Date: 2015-09-29 16:01:29</p>
<p>Bei einer Debatte unter Freunden über Protocol Buffers, JSON und ASN.1
kam gerade dieses Bonmot:</p>
<blockquote>
<p>JSON ist halt für Leute denen XML zu komplex ist.<br />
XML ist für Leute denen ASN.1 zu komplex war.<br />
Protobuf ist für Leute, denen JSON zu langsam ist</p>
</blockquote>
<p>Das bringt es ganz gut auf dem Punkt, finde ich.</p>
<p>Wobei man das ja eigentlich noch erweitern müssten. Die Komplexität von
XML hat ja die von ASN.1 übertroffen (es gibt eine ASN.1-Abbildung nach
XML aber nicht umgekehrt).</p>
<p>Ich muss ja sagen, dass ich ein Freund von ASN.1 bin. Anfangs habe ich
es für einen großen Mist gehalten, aber inzwischen habe ich meine
Meinung geändert. Selbst der Schachtelungswahnsinn bei LDAP ist bei
näherer Betrachtung verteidigbar.</p>
<p>Aber so im Vergleich zu ASN.1/DER hat Protocol Buffers irgendwie nur
Nachteile. Besonders ärgerlich weil vermeidbar finde ich, dass sie am
Anfang nicht die Länge mitschicken. Wenn man schon seine Daten
serialisieren muss, dann will man doch wenigstens einen
Zero-Copy-Decoder haben. Das heißt, ich will auf einen gesendeten String
zugreifen, ohne den rauskopieren zu müssen. Und Zero-Copy heißt halt
auch, dass man am Anfang weiß, wie groß die Nachricht werden wird. Denn
sonst muss man lesen, was kommt, und immer mehr Speicher dazu allozieren
und umkopieren, was wir ja gerade vermeiden wollten. Wenn ich das
richtig sehe gerade, dann hat Protocol Buffers keine Längenübertragung
am Anfang. Und keinen Ende-Marker. Wenn ich also zwei Protocol Buffers
hintereinander übertragen will, weil ich im Protokoll Pipelining
unterstützen will, dann gibt das einen Konflikt mit der Erweiterbarkeit.
Hey, ASN.1/DER hat seit den 80ern Pipelining und Erweiterbarkeit drin.
Wie arm ist DAS denn, sowas dann wegen \&ldquo;not invented here\&rdquo;
wegzuschmeißen und neu zu machen <em>und dann schlechter als das Original
zu sein</em>. Die sollten sich alle mal was schämen.</p>
<p>Aber das Tooling ist so toll!1!! Ja, äh, und? Du bist ein fucking Coder.
Code dir halt dein Tooling selbst. WTF? Seit wann ist diese \&ldquo;wische mir
doch mal bitte jemand den Arsch ab\&ldquo;-Mentalität eigentlich
gesellschaftlich akzeptabel geworden?</p>
</div>
</div>
</div>
<script src="js/ui.js"></script>
</body>
</html>
