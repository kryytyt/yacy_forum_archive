<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="generator" content="Hugo 0.37.1" />

  <title> &middot; Yacy Old Forum Archiv</title>

  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/pure-min.css">

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-old-ie-min.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-min.css">
  <!--<![endif]-->

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="/css/side-menu-old-ie.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="/css/side-menu.css">
  <!--<![endif]-->

  <link rel="stylesheet" href="/css/blackburn.css">

  
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  
  <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

 
  

  

  <link rel="shortcut icon" href="img/favicon.ico" type="image/x-icon" />

  
  

</head>


<body>
<div id="layout">

  
<a href="#menu" id="menuLink" class="menu-link">
  
  <span></span>
</a>
<div id="menu">

  

  <div class="pure-menu">
    <ul class="pure-menu-list">
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="/"><i class='fa fa-home fa-fw'></i>Home</a>
      
        </li>
      
    </ul>
  </div>

  <div class="pure-menu social">
  <ul class="pure-menu-list">

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://twitter.com/http://twitter.com/yacy_search" target="_blank"><i class="fa fa-twitter-square fa-fw"></i>Twitter</a>
    </li>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://github.com/yacy" target="_blank"><i class="fa fa-github-square fa-fw"></i>GitHub</a>
    </li>
    

    

    

    

    

    

    

    

    

    

    

    

    

  </ul>
</div>


  <div>
  <div class="small-print">
    <small></small>
  </div>
  <div class="small-print">
    <small>Built with&nbsp;<a href="https://gohugo.io/" target="_blank">Hugo</a></small>
    <small>Theme&nbsp;<a href="https://github.com/yoshiharuyamashita/blackburn" target="_blank">Blackburn</a></small>
  </div>
</div>

</div>


  <div id="main">


<div class="header">
  <h1></h1>
  <h2></h2>
</div>
<div class="content">
  

<h1 id="kurze-programmierer-frage-vielleicht-kann-das-ja-jemand">Kurze Programmierer-Frage. Vielleicht kann das ja jemand ...</h1>

<p>Date: 2015-04-19 10:08:49</p>

<p>Kurze Programmierer-Frage. Vielleicht kann das ja jemand von euch
autoritativ beantworten.</p>

<p>Ich habe mir vorhin folgendes überlegt. Nehmt euch mal sowas wie stdio.
Ausgaberoutinen. printf.</p>

<p>Da werden in Reihe lauter kleine Strings in einen Buffer geschoben. Im
Normalfall ist in dem Buffer ausreichend Platz für den String.</p>

<p>Mir geht es konkret gerade um libowfat, nicht libc, aber die Konzepte
sind ja die selben.</p>

<p>Mein Buffer-Interface hat ein buffer_puts (nimmt einen const char*)
und buffer_put (nimmt const char* und ein size_t). buffer_puts ruft
buffer_put auf und übergibt strlen() von dem String als Länge.</p>

<p>In dem Fall, in dem man einen konstanten String ausgibt, kann man sich
das strlen mit einer gcc-Extension sparen. Das sieht dann in der Praxis
so aus:</p>

<pre><code>#define buffer_puts(b,s) (__builtin_constant_p(s) ? buffer_put(b,s,strlen(s)) : buffer_puts(b,s))
</code></pre>

<p>__builtin_constant_p evaluiert zu 1, wenn s zur Compile-Zeit als
konstant bekannt ist. In dem Fall ist das strlen kostenlos, wenn ich es
in dem Makro mache. So wird dann</p>

<pre><code>buffer_puts(buffer_1,&quot;foo\n&quot;);
</code></pre>

<p>zu</p>

<pre><code>buffer_put(buffer_1,&quot;foo\n&quot;,4);
</code></pre>

<p>Soweit, so gut.</p>

<p>Die nächste Überlegung war: Wenn ich in buffer_put nun memcpy von dem
Quell-Puffer in den Ziel-Puffer mache, dann ist in dem Ziel-Puffer
normalerweise noch genug Platz, und es macht auch nichts, wenn ich da
ein paar Bytes mehr schreibe (solange ich vorher geguckt habe, ob genug
Platz ist, versteht sich). Eigentlich kann ich da statt byteweise auch
gleich in 16-Byte-Vektoren kopieren. Auf aktuellem x86 kosten unalignete
Zugriffe nichts zusätzlich. Wenn da also jemand \&ldquo;foo\n\&rdquo; schreiben
will, kann ich auch einfach 16 Bytes schreiben, von denen in den
vorderen \&ldquo;foo\n\&rdquo; steht. Die entsprechende Buchhaltung in dem Buffer
muss ich natürlich mit der gewünschten Länge machen, nicht aufgerundet.</p>

<p>Aber dann dachte ich mir: OK, beim Schreiben ist das OK, wenn ich mehr
schreibe, das habe ich unter Kontrolle. Aber wie ist das beim Lesen? Ist
es denkbar, dass ein Programm mir den letzten String im
Read-Only-Datensegment übergibt, und wenn ich da einen ganzen Vektor
lese, dann renne ich über das Seitenende hinaus und crashe das Programm?</p>

<p>Für mein Dafürhalten sieht das gerade eher unwahrscheinlich aus. In
meinem Testprogramm kommen nach meinen Konstanten noch die ganzen
Konstanten der libc. Und dann sind hinter dem letzten String auch noch
mal ein paar Nullbytes Alignment vom Linker.</p>

<p>Meine Frage jetzt: Kennt jemand ein Szenario, in dem man nicht noch
(schlimmstenfalls) 15 weitere Bytes hinter dem Ende eines konstanten
Strings lesen kann? Wie ist das bei Windows? Wohlgemerkt reicht es
nicht, wenn das ein const char* ist, damit das getriggert wird. Das
muss tatsächlich eine Stringkonstante sein.</p>

<p><strong>Update</strong>: Valgrind hat keine Einwände.</p>

</div>

</div>
</div>
<script src="js/ui.js"></script>






</body>
</html>

