<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="generator" content="Hugo 0.37.1" />
  <title> &middot; Yacy Old Forum Archiv</title>
  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/pure-min.css">
  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-old-ie-min.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-min.css">
  <!--<![endif]-->
  <!--[if lte IE 8]>
  <link rel="stylesheet" href="/css/side-menu-old-ie.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="/css/side-menu.css">
  <!--<![endif]-->
  <link rel="stylesheet" href="/css/blackburn.css">
  
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  
  <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
 
  
  
  <link rel="shortcut icon" href="img/favicon.ico" type="image/x-icon" />
  
  
</head>
<body>
<div id="layout">
  
<a href="#menu" id="menuLink" class="menu-link">
  
  <span></span>
</a>
<div id="menu">
  
  <div class="pure-menu">
    <ul class="pure-menu-list">
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="/"><i class='fa fa-home fa-fw'></i>Home</a>
      
        </li>
      
    </ul>
  </div>
  <div class="pure-menu social">
  <ul class="pure-menu-list">
    
    
    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://twitter.com/http://twitter.com/yacy_search" target="_blank"><i class="fa fa-twitter-square fa-fw"></i>Twitter</a>
    </li>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://github.com/yacy" target="_blank"><i class="fa fa-github-square fa-fw"></i>GitHub</a>
    </li>
    
    
    
    
    
    
    
    
    
    
    
    
    
  </ul>
</div>
  <div>
  <div class="small-print">
    <small></small>
  </div>
  <div class="small-print">
    <small>Built with&nbsp;<a href="https://gohugo.io/" target="_blank">Hugo</a></small>
    <small>Theme&nbsp;<a href="https://github.com/yoshiharuyamashita/blackburn" target="_blank">Blackburn</a></small>
  </div>
</div>
</div>
  <div id="main">
<div class="header">
  <h1></h1>
  <h2></h2>
</div>
<div class="content">
  
<h1 id="yacy-coding-architektur-re-bilder-doubletten-erkennen">YaCy Coding &amp; Architektur • Re: Bilder Doubletten erkennen</h1>
<p>Date: 2014-02-09 21:37:45</p>
<p>Hier mal mein alter Code von damals. Mein Versuch von damals ist mit
Skalierung, Anpassung der Farben und Weichzeicher deutlich schneller als
der ImageParser (zwischen 50% und 25 % der Zeit). Der große Nachteil
meines Algorithmus ist, dass er sich durch geringfügig unterschiedliche
Bildausschnitte schon durcheinander bringen lässt. Außerdem ist mein
\&ldquo;ImageHash\&rdquo; viel länger als die Image-Momente.<br />
<br />
Es wäre mal nett zu sehen, ob der Image-Parser mit meinen
\&ldquo;Normalisierungsmethoden\&rdquo; deutlich schneller laufen würde und
eventuell qualitativ ähnliche Ergebnisse liefern würde. Dazu bin ich nur
heute Abend zu müde/faul.<br />
</p>
<dl>
<dt>Code:</dt>
<dd><code>import java.awt.geom.AffineTransform;import java.awt.image.AffineTransformOp;import java.awt.image.BufferedImage;import java.awt.image.BufferedImageOp;import java.awt.image.ConvolveOp;import java.awt.image.Kernel;import java.io.File;import java.io.IOException;import java.util.Arrays;import javax.imageio.ImageIO;/** * * @author low012 */public final class ImageHash {    private final static int BLOCK_WIDTH = 8;    private final static int BLOCK_HEIGHT = 8;    private final static int BLOCKS_HORIZONTAL = 8;    private final static int BLOCKS_VERTICAL = 8;    private final static int RESIZE_WIDTH = BLOCKS_HORIZONTAL * BLOCK_WIDTH;    private final static int RESIZE_HEIGHT = BLOCKS_VERTICAL * BLOCK_HEIGHT;    final static int DIVIDER = 8;    private byte[] imageHash;    public ImageHash(final BufferedImage image) {        this(createImageHash(image));    }    public ImageHash(final byte[] imageHash) {        this.imageHash = imageHash;    }    public byte[] getByteArray() {        return imageHash;    }        @Override    public boolean equals(final Object o) {        final boolean ret;        if (o == null) {            ret = false;        } else if (o instanceof BufferedImage) {            ret = isSimilar(this.getByteArray(), (BufferedImage) o);        } else if (o instanceof byte[]) {            ret = isSimilar(this.getByteArray(), (byte[]) o);        } else if (o instanceof ImageHash) {            ret = isSimilar(this.getByteArray(), ((ImageHash) o).getByteArray());        } else {            ret = false;        }        return ret;    }    @Override    public int hashCode() {        int hash = 5;        hash = 37 * hash + Arrays.hashCode(this.imageHash);        return hash;    }    private boolean isSimilar(final byte[] imageHash, final BufferedImage image) {        return isSimilar(imageHash, normalize(image));    }    private boolean isSimilar(final byte[] imageHash1, final byte[] imageHash2) {                final int l = imageHash1.length;        if (l != imageHash2.length) {            throw new IllegalArgumentException(&quot;ImageHashs need to have same length: &quot; +                    l + &quot; &quot; + imageHash2.length);        }        int error = 0;        for (int i = 0; i &lt; l &amp;&amp; error &lt; 500; i++) {            if (Math.abs((imageHash1[i] &amp; 0xff) - (imageHash2[i] &amp; 0xff)) &gt; 1) {                error++;            }        }        /**         * The value of 0.01 has been found by experimenting with images from         * http://www.kasrl.org/jaffe.html and different size of the image at         * http://en.wikipedia.org/wiki/File:Hillary_Clinton_Bill_Chelsea_on_parade.jpg         *         * 0.01 seems to be low enough to ensure that very similar, but still         * clearly different images (slight change of angle from which an image         * has been taken, small changes in facial expression) will be detected as         * different, but resized images will be detected as not different.         *         * Try higher values to make the algorithm less strict.         */        return error &lt; (l * 0.01);    }    private static byte[] createImageHash(final BufferedImage image) {        if (image == null) {            throw new IllegalArgumentException(&quot;Image may not be null!&quot;);        }        final byte[] b = normalize(image);        final byte[] ret = new byte[BLOCKS_VERTICAL * BLOCKS_HORIZONTAL * 3];        byte min;        byte max;        int sum;        byte val;        int i = 0;        for (int v = 0; v &lt; BLOCKS_VERTICAL; v++) {            for (int h = 0; h &lt; BLOCKS_HORIZONTAL; h++) {                min = (byte) 0xff;                max = (byte) 0x00;                sum = (byte) 0x00;                for (int bh = 0; bh &lt; BLOCK_HEIGHT; bh++) {                    for (int bw = 0; bw &lt; BLOCK_WIDTH; bw++) {                        val = b[(v * BLOCK_HEIGHT * RESIZE_WIDTH) + (h * BLOCK_WIDTH) + (bh * RESIZE_WIDTH) + bw];                        if ((val &amp; 0xff) &lt; (min &amp; 0xff)) {                            min = val;                        }                        if ((val &amp; 0xff) &gt; (max &amp; 0xff)) {                            max = val;                        }                        sum += val &amp; 0xff;                                            }                }                ret[i++] = (byte) ((min &amp; 0xff) / DIVIDER);                ret[i++] = (byte) ((max &amp; 0xff) / DIVIDER);                // Besser statt Durchschnitt Median?                ret[i++] = (byte) ((sum / (BLOCK_WIDTH * BLOCK_HEIGHT) &amp; 0xff) / DIVIDER);            }        }        return ret;    }    private static byte[] normalize(final BufferedImage image) {        return bufferedGrayscaleImageToByteArray(spreadGrayValues(blur(toGrayScale(scale(image, RESIZE_WIDTH, RESIZE_HEIGHT)))));    }    private static BufferedImage scale(final BufferedImage image, final int width, final int height) {        final AffineTransform tx = new AffineTransform();        tx.scale((float)width/image.getWidth(), (float)height/image.getHeight());        final AffineTransformOp affineTransformOp = new AffineTransformOp(tx, AffineTransformOp.TYPE_NEAREST_NEIGHBOR);        return affineTransformOp.filter(image, null);    }    private static BufferedImage blur(final BufferedImage image) {        final Kernel kernel = new Kernel(3, 3,            new float[] {                1f/9f, 1f/9f, 1f/9f,                1f/9f, 1f/9f, 1f/9f,                1f/9f, 1f/9f, 1f/9f});        final BufferedImageOp op = new ConvolveOp(kernel);        final BufferedImage ret = new BufferedImage(image.getWidth(), image.getHeight(), image.getType());        op.filter(image, ret);        return ret;    }    private static BufferedImage toGrayScale(final BufferedImage image) {        final BufferedImage ret = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_BYTE_GRAY );        ret.getGraphics().drawImage(image, 0, 0, null);        return ret;    }    private static BufferedImage spreadGrayValues(final BufferedImage image) {        int minGray = 255;        int maxGray = 0;        final int width = image.getWidth();        final int height = image.getHeight();        int rgb;        for (int i = 0; i &lt; width; i++) {            for (int j = 0; j &lt; height; j++) {                rgb = image.getRGB(i, j) &gt;&gt; 16 &amp; 0xff;                if (rgb &lt; minGray) {                    minGray = rgb;                }                if (rgb &gt; maxGray) {                    maxGray = rgb;                }            }        }        final BufferedImage ret = new BufferedImage(width, height, image.getType());        int o, n;        for (int i = 0; i &lt; width; i++) {            for (int j = 0; j &lt; height; j++) {                o = image.getRGB(i, j) &gt;&gt; 16 &amp; 0xff;                n = (int)(255f * ((float)(o -minGray) / (float)(maxGray - minGray)));                ret.setRGB(i, j, (n &lt;&lt; 16) + (n &lt;&lt; 8) + n);            }        }        return ret;    }    private static byte[] bufferedGrayscaleImageToByteArray(final BufferedImage image) {        final int width = image.getWidth();        final int height = image.getHeight();        final byte[] bytes = new byte[width * height];        int a = 0;        for (int i = 0; i &lt; height; i++) {            for (int j = 0; j &lt; width; j++) {                bytes[a++] = (byte) (image.getRGB(j, i) &amp; 0xff);            }        }        return bytes;    }    public static void main(final String[] args) throws IOException {              long t = System.currentTimeMillis();               new ImageHash(ImageIO.read(new File(&quot;/mnt/Daten/dev/eclipse/testproj/kfz3.png&quot;)));        System.out.println(System.currentTimeMillis() - t);        t = System.currentTimeMillis();        new ImageHash(ImageIO.read(new File(&quot;/mnt/Daten/dev/eclipse/testproj/kfz1.png&quot;)));        System.out.println(System.currentTimeMillis() - t);        t = System.currentTimeMillis();        new ImageHash(ImageIO.read(new File(&quot;/mnt/Daten/dev/eclipse/testproj/kfz2.png&quot;)));        System.out.println(System.currentTimeMillis() - t);        t = System.currentTimeMillis();        new ImageHash(ImageIO.read(new File(&quot;/mnt/Daten/dev/eclipse/testproj/kfz3.png&quot;)));        System.out.println(System.currentTimeMillis() - t);        t = System.currentTimeMillis();        new ImageHash(ImageIO.read(new File(&quot;/mnt/Daten/dev/eclipse/testproj/kfz4.png&quot;)));        System.out.println(System.currentTimeMillis() - t);        t = System.currentTimeMillis();        new ImageHash(ImageIO.read(new File(&quot;/mnt/Daten/dev/eclipse/testproj/kfz5.png&quot;)));        System.out.println(System.currentTimeMillis() - t);    }}</code></dd>
</dl>
<p>Statistik: Verfasst von
<a href="http://forum.yacy-websuche.de/memberlist.php?mode=viewprofile&amp;u=62">Low012</a>
&mdash; So Feb 09, 2014 9:37 pm</p>
<hr />
</div>
</div>
</div>
<script src="js/ui.js"></script>
</body>
</html>
