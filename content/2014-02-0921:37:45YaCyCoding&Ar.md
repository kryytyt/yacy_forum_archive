YaCy Coding & Architektur • Re: Bilder Doubletten erkennen
==========================================================

Date: 2014-02-09 21:37:45

Hier mal mein alter Code von damals. Mein Versuch von damals ist mit
Skalierung, Anpassung der Farben und Weichzeicher deutlich schneller als
der ImageParser (zwischen 50% und 25 % der Zeit). Der große Nachteil
meines Algorithmus ist, dass er sich durch geringfügig unterschiedliche
Bildausschnitte schon durcheinander bringen lässt. Außerdem ist mein
\"ImageHash\" viel länger als die Image-Momente.\
\
Es wäre mal nett zu sehen, ob der Image-Parser mit meinen
\"Normalisierungsmethoden\" deutlich schneller laufen würde und
eventuell qualitativ ähnliche Ergebnisse liefern würde. Dazu bin ich nur
heute Abend zu müde/faul.\
\

Code: 
:   `import java.awt.geom.AffineTransform;import java.awt.image.AffineTransformOp;import java.awt.image.BufferedImage;import java.awt.image.BufferedImageOp;import java.awt.image.ConvolveOp;import java.awt.image.Kernel;import java.io.File;import java.io.IOException;import java.util.Arrays;import javax.imageio.ImageIO;/** * * @author low012 */public final class ImageHash {    private final static int BLOCK_WIDTH = 8;    private final static int BLOCK_HEIGHT = 8;    private final static int BLOCKS_HORIZONTAL = 8;    private final static int BLOCKS_VERTICAL = 8;    private final static int RESIZE_WIDTH = BLOCKS_HORIZONTAL * BLOCK_WIDTH;    private final static int RESIZE_HEIGHT = BLOCKS_VERTICAL * BLOCK_HEIGHT;    final static int DIVIDER = 8;    private byte[] imageHash;    public ImageHash(final BufferedImage image) {        this(createImageHash(image));    }    public ImageHash(final byte[] imageHash) {        this.imageHash = imageHash;    }    public byte[] getByteArray() {        return imageHash;    }        @Override    public boolean equals(final Object o) {        final boolean ret;        if (o == null) {            ret = false;        } else if (o instanceof BufferedImage) {            ret = isSimilar(this.getByteArray(), (BufferedImage) o);        } else if (o instanceof byte[]) {            ret = isSimilar(this.getByteArray(), (byte[]) o);        } else if (o instanceof ImageHash) {            ret = isSimilar(this.getByteArray(), ((ImageHash) o).getByteArray());        } else {            ret = false;        }        return ret;    }    @Override    public int hashCode() {        int hash = 5;        hash = 37 * hash + Arrays.hashCode(this.imageHash);        return hash;    }    private boolean isSimilar(final byte[] imageHash, final BufferedImage image) {        return isSimilar(imageHash, normalize(image));    }    private boolean isSimilar(final byte[] imageHash1, final byte[] imageHash2) {                final int l = imageHash1.length;        if (l != imageHash2.length) {            throw new IllegalArgumentException("ImageHashs need to have same length: " +                    l + " " + imageHash2.length);        }        int error = 0;        for (int i = 0; i < l && error < 500; i++) {            if (Math.abs((imageHash1[i] & 0xff) - (imageHash2[i] & 0xff)) > 1) {                error++;            }        }        /**         * The value of 0.01 has been found by experimenting with images from         * http://www.kasrl.org/jaffe.html and different size of the image at         * http://en.wikipedia.org/wiki/File:Hillary_Clinton_Bill_Chelsea_on_parade.jpg         *         * 0.01 seems to be low enough to ensure that very similar, but still         * clearly different images (slight change of angle from which an image         * has been taken, small changes in facial expression) will be detected as         * different, but resized images will be detected as not different.         *         * Try higher values to make the algorithm less strict.         */        return error < (l * 0.01);    }    private static byte[] createImageHash(final BufferedImage image) {        if (image == null) {            throw new IllegalArgumentException("Image may not be null!");        }        final byte[] b = normalize(image);        final byte[] ret = new byte[BLOCKS_VERTICAL * BLOCKS_HORIZONTAL * 3];        byte min;        byte max;        int sum;        byte val;        int i = 0;        for (int v = 0; v < BLOCKS_VERTICAL; v++) {            for (int h = 0; h < BLOCKS_HORIZONTAL; h++) {                min = (byte) 0xff;                max = (byte) 0x00;                sum = (byte) 0x00;                for (int bh = 0; bh < BLOCK_HEIGHT; bh++) {                    for (int bw = 0; bw < BLOCK_WIDTH; bw++) {                        val = b[(v * BLOCK_HEIGHT * RESIZE_WIDTH) + (h * BLOCK_WIDTH) + (bh * RESIZE_WIDTH) + bw];                        if ((val & 0xff) < (min & 0xff)) {                            min = val;                        }                        if ((val & 0xff) > (max & 0xff)) {                            max = val;                        }                        sum += val & 0xff;                                            }                }                ret[i++] = (byte) ((min & 0xff) / DIVIDER);                ret[i++] = (byte) ((max & 0xff) / DIVIDER);                // Besser statt Durchschnitt Median?                ret[i++] = (byte) ((sum / (BLOCK_WIDTH * BLOCK_HEIGHT) & 0xff) / DIVIDER);            }        }        return ret;    }    private static byte[] normalize(final BufferedImage image) {        return bufferedGrayscaleImageToByteArray(spreadGrayValues(blur(toGrayScale(scale(image, RESIZE_WIDTH, RESIZE_HEIGHT)))));    }    private static BufferedImage scale(final BufferedImage image, final int width, final int height) {        final AffineTransform tx = new AffineTransform();        tx.scale((float)width/image.getWidth(), (float)height/image.getHeight());        final AffineTransformOp affineTransformOp = new AffineTransformOp(tx, AffineTransformOp.TYPE_NEAREST_NEIGHBOR);        return affineTransformOp.filter(image, null);    }    private static BufferedImage blur(final BufferedImage image) {        final Kernel kernel = new Kernel(3, 3,            new float[] {                1f/9f, 1f/9f, 1f/9f,                1f/9f, 1f/9f, 1f/9f,                1f/9f, 1f/9f, 1f/9f});        final BufferedImageOp op = new ConvolveOp(kernel);        final BufferedImage ret = new BufferedImage(image.getWidth(), image.getHeight(), image.getType());        op.filter(image, ret);        return ret;    }    private static BufferedImage toGrayScale(final BufferedImage image) {        final BufferedImage ret = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_BYTE_GRAY );        ret.getGraphics().drawImage(image, 0, 0, null);        return ret;    }    private static BufferedImage spreadGrayValues(final BufferedImage image) {        int minGray = 255;        int maxGray = 0;        final int width = image.getWidth();        final int height = image.getHeight();        int rgb;        for (int i = 0; i < width; i++) {            for (int j = 0; j < height; j++) {                rgb = image.getRGB(i, j) >> 16 & 0xff;                if (rgb < minGray) {                    minGray = rgb;                }                if (rgb > maxGray) {                    maxGray = rgb;                }            }        }        final BufferedImage ret = new BufferedImage(width, height, image.getType());        int o, n;        for (int i = 0; i < width; i++) {            for (int j = 0; j < height; j++) {                o = image.getRGB(i, j) >> 16 & 0xff;                n = (int)(255f * ((float)(o -minGray) / (float)(maxGray - minGray)));                ret.setRGB(i, j, (n << 16) + (n << 8) + n);            }        }        return ret;    }    private static byte[] bufferedGrayscaleImageToByteArray(final BufferedImage image) {        final int width = image.getWidth();        final int height = image.getHeight();        final byte[] bytes = new byte[width * height];        int a = 0;        for (int i = 0; i < height; i++) {            for (int j = 0; j < width; j++) {                bytes[a++] = (byte) (image.getRGB(j, i) & 0xff);            }        }        return bytes;    }    public static void main(final String[] args) throws IOException {              long t = System.currentTimeMillis();               new ImageHash(ImageIO.read(new File("/mnt/Daten/dev/eclipse/testproj/kfz3.png")));        System.out.println(System.currentTimeMillis() - t);        t = System.currentTimeMillis();        new ImageHash(ImageIO.read(new File("/mnt/Daten/dev/eclipse/testproj/kfz1.png")));        System.out.println(System.currentTimeMillis() - t);        t = System.currentTimeMillis();        new ImageHash(ImageIO.read(new File("/mnt/Daten/dev/eclipse/testproj/kfz2.png")));        System.out.println(System.currentTimeMillis() - t);        t = System.currentTimeMillis();        new ImageHash(ImageIO.read(new File("/mnt/Daten/dev/eclipse/testproj/kfz3.png")));        System.out.println(System.currentTimeMillis() - t);        t = System.currentTimeMillis();        new ImageHash(ImageIO.read(new File("/mnt/Daten/dev/eclipse/testproj/kfz4.png")));        System.out.println(System.currentTimeMillis() - t);        t = System.currentTimeMillis();        new ImageHash(ImageIO.read(new File("/mnt/Daten/dev/eclipse/testproj/kfz5.png")));        System.out.println(System.currentTimeMillis() - t);    }}`

Statistik: Verfasst von
[Low012](http://forum.yacy-websuche.de/memberlist.php?mode=viewprofile&u=62)
--- So Feb 09, 2014 9:37 pm

------------------------------------------------------------------------
